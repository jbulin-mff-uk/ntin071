\documentclass[handout]{beamer}

\input{header.tex}


\title{Lecture 7 -- Pushdown automata}


\begin{document}


\frame{\titlepage}


\begin{frame}{Recap of Lecture 6}
	
    \begin{itemize}
		\item Reducing a grammar: removing $\epsilon$-productions, unit productions, useless symbols
		\item Chomsky Normal Form of a context-free grammar
		\item Pumping lemma for context-free languages, application: proving non-context-freeness
		\item Testing membership in a context-free language: the CYK algorithm
	\end{itemize}
	
\end{frame}


\section{2.9 Pushdown automata}


\begin{frame}{Pushdown automaton (PDA)}

    \vspace{-6pt}
    \begin{center}
        \includegraphics[width=0.6\textwidth]{files/pushDown.PNG}
    \end{center}
    \vspace{-12pt}

    \begin{itemize}
        \item an extension of $\epsilon$--NFA, additional feature: a \alert{stack} memory %(push, pop -- only at the top)
        \item the stack has its own \alert{stack alphabet} $\Gamma$ (can contain $\Sigma$ or not)
        \item at each step we pop the top stack symbol $X$, make a decision based on $(q,a,X)$, push some word $\gamma\in\gamma^*$
        \item the stack can rememeber an infinite amount of information
        \item PDA define context-free languages, nondeterminism is important: \alert{deterministic} PDA only recognize a proper subset of context-free languages (unlike DFA vs. NFA)
    \end{itemize}
    
\end{frame}


\begin{frame}{The definition}

    \alert{A pushdown automaton} (\alert{PDA}): $P=(Q,\Sigma,\Gamma,\delta,q_0,Z_0,F)$, where
        
    \begin{itemize}
        \item $Q$ is finite, nonempty set of states
        \item $\Sigma$ is a finite, nonempty \alert{input alphabet}
        \item $\Gamma$ is a finite, nonempty \alert{stack alphabet}
        \item $\delta$ is the \alert{transition function}, 
        $$
        \delta\colon Q\times (\Sigma\cup \{\epsilon\})\times \Gamma \to \mathcal P_{FIN}(Q \times \Gamma^*)
        $$ 
        $\delta(q,a,X)\ni(p,\gamma)$ where $p$ is the new state and $\gamma$ a finite string of stack symbols that \alert{replace} $X$ on top of the stack
        \item $q_0\in Q$ is the \alert{initial state}
        \item $Z_0\in\Gamma$ is the \alert{initial stack symbol} (\alert{bottom of the stack}); the only symbol on the stack at the beginning
        \item $F$ is a set of \alert{accepting} (\alert{final}) states; may be undefined if our PDA \alert{accepts by empty stack}
    \end{itemize}

\end{frame}


\begin{frame}{One transition of a PDA}   

    \begin{itemize}
        \item read one input letter ($a\in\Sigma$) or do an $\epsilon$-transition ($a=\epsilon$)
        \item pop $X$ from the top of the stack
        \item based on $a$, $X$, and the current state $q$ nondeterministically choose one of finitely many options $(p,\gamma)\in\delta(q,a,X)$
        \item switch to the new state $p$
        \item push the finite string $\gamma$ to the stack (the first symbol of $\Gamma$ is now on top)
        \item \alert{pop}: $\gamma=\epsilon$, \alert{read} only: $\gamma=X$, \alert{push}: $\gamma=\gamma'X$
\end{itemize}

\end{frame}


\begin{frame}{Example: $L_{wwr}=\{ww^R\mid w \in \{0,1\}^*\}$}

    \begin{center}
        \scalebox{0.95}{
        \begin{tikzpicture}[]
            \node[initial,state] (q0)      {$q_0$};
            \node[state] (q1)  [right=2cm of q0]     {$q_1$};
            \node[state, accepting] (q2)  [right=2cm of q1]    {$q_2$};
            \path[->]
                (q0)  edge[loop above]  node[align=center] {
                                        $0,Z_0 \rightarrow 0Z_0$	\\
                                        $1,Z_0 \rightarrow 1Z_0$	\\			
                                        $0,0 \rightarrow 00$	\\			
                                        $0,1 \rightarrow 01$	\\			
                                        $1,0 \rightarrow 10$	\\			
                                        $1,1 \rightarrow 11$			
                                        } (q0)
                (q0)  edge[swap]  node[align=center] {
                                        $\epsilon,Z_0 \rightarrow Z_0$	\\			
                                        $\epsilon,0 \rightarrow 0$	\\			
                                        $\epsilon,1 \rightarrow 1$			
                                        }  (q1)
                (q1)  edge[loop above]  node[align=center] {
                                        $0,0 \rightarrow \epsilon$	\\			
                                        $1,1 \rightarrow \epsilon$			
                                        } (q1)
                (q1)  edge[swap]  node[align=center] {
                                        $\epsilon,Z_0 \rightarrow Z_0$	
                                        } (q2)
                ;
        \end{tikzpicture}
        }
    \end{center}

    \vspace{-12pt}   
    
    \alert{$q_0$} read input letters pushing them onto the stack; guess the middle (nondeterministically), jump to $q_1$\\
    \alert{$q_1$} compare input with stack, consuming both; if empty stack (we see the bottom), accept by jumping to $q_2$; no input can remain

\end{frame}


\begin{frame}{Example cont'd: full description of the PDA}

    \begin{center}
        $P=(\{q_0,q_1,q_2\},\{0,1\},\{0,1,Z_0\},\delta,q_0,Z_0,\{q_2\})$
    \end{center}

    \begin{tabular}{l l}\hline
        $\delta(q_0,0,Z_0)=\{(q_0,0Z_0)\}$ &  
            \multirow{2}{*}{push input onto stack, leave the bottom} \\
        $\delta(q_0,1,Z_0)=\{(q_0,1Z_0)\}$ &  \\\hline
        $\delta(q_0,0,0)=\{(q_0,00)\}$ &  
            \multirow{4}{*}{stay in $q_0$, push input onto stack}\\ 
        $\delta(q_0,0,1)=\{(q_0,01)\}$ \\
        $\delta(q_0,1,0)=\{(q_0,10)\}$ \\
        $\delta(q_0,1,1)=\{(q_0,11)\}$ \\ \hline
        $\delta(q_0,\epsilon,Z_0)=\{(q_1,Z_0)\}$ &
            \multirow{3}{*}{jump to $q_1$ without changing stack}\\ 
        $\delta(q_0,\epsilon,0)=\{(q_1,0)\}$ \\
        $\delta(q_0,\epsilon,1)=\{(q_1,1)\}$ \\ \hline
        $\delta(q_1,0,0)=\{(q_1,\epsilon)\}$ &
            \multirow{2}{*}{pop stack and match with input}\\ 
        $\delta(q_1,1,1)=\{(q_1,\epsilon)\}$ \\ \hline
        $\delta(q_1,\epsilon,Z_0)=\{(q_2,Z_0)\}$ & we have $ww^R$, go to accepting state
        \\\hline
    \end{tabular}

\end{frame}


\begin{frame}{Notation}

    \begin{center}
        \begin{tabular}{l l}
            $a,b,c$ & symbols of the input alphabet\\
            $q,p, r$ & states\\
            $u,w,x,y,z$ & words over input alphabet\\
            $X,Y,A,B$ & stack symbols\\
            $Z_0$ & bottom of the stack symbol\\
            $\alpha,\beta,\gamma$ & words over stack alphabet		
        \end{tabular}
    \end{center}

    \bigskip

    Transition diagram:
    \begin{itemize}
        \item nodes are states, initial and final denoted as usual
        \item a transition $\delta(q,a,X)\ni (p,\alpha)$: arc from $p$ to $q$ labelled $a,X\rightarrow \alpha$          
    \end{itemize}

\end{frame}


\section*{The languages of a PDA}


\begin{frame}{Configurations and moves (computation graph)}

    A \alert{configuration} of a PDA is a triple \alert{$(q,w,\gamma)$}, where
    \begin{description}
        \item[$q$] is the current state 
        \item[$w$] is the remaining input and
        \item[$\gamma$] is the stack contents (the top is on the left) 
    \end{description}

    We define \alert{moves} between configurations (\alert{$\vdash_P$} or \alert{$\vdash$}) thus: for any transition $\delta(q,a,X)\ni(p,\alpha)$ and all $w\in \Sigma^*$ and $\beta\in \Gamma^*$ we have
    $$
    (q,aw,X\beta)\vdash (p,w,\alpha\beta)
    $$
    We use the symbol \alert{$\vdash^*_P$} or \alert{$\vdash^*$} to represent zero or more moves, i.e.
    \begin{itemize}
        \item $I\vdash^*I$ for any configuration $I$
        \item $I\vdash^*J$ if there exists $K$ such that $I\vdash K$ and $K\vdash^*J$
    \end{itemize}

\end{frame}


\begin{frame}{Initial and accepting configurations, the languages of a PDA}

    The \alert{initial configuration} of $P=(Q,\Sigma,\Gamma,\delta,q_0,Z_0,F)$ for input word $w\in\Sigma^*$ is \alert{$(q_0,w,Z_0)$}. Which configurations are \alert{accepting}? 
    
    Two options:

    \textbf{1. Acceptance by final state:} \alert{$(f,\epsilon,\gamma)$} for some final state $f\in F$ and arbitrary stack contents $\gamma\in\Gamma^*$


    $\alert{L(P)}=\{w\mid (q_0,w,Z_0)\vdash^*_P (f,\epsilon,\gamma)\text{ for some }f\in F\text{ and }\gamma\in\Gamma^*\}$

    \bigskip

    \textbf{2. Acceptance by empty stack:} \alert{$(q,\epsilon,\epsilon)$} for an arbitrary $q\in Q$

    $\alert{N(P)}=\{w\mid (q_0,w,Z_0)\vdash^*_P (q,\epsilon,\epsilon)\text{ for any }q\in Q\}$

    \medskip

    In this case we can write only $P=(Q,\Sigma,\Gamma,\delta,q_0,Z_0)$    

\end{frame}


\begin{frame}{Configurations for the input $w=1111$}

    \begin{center}
        \scalebox{0.8}{
            \begin{forest}
                for tree={edge=->}
                [{$(q_0, 1111, Z_0)$},tikz={\node [draw,green,fit=()] {};}
                    [{$(q_0, 111, 1Z_0)$}
                    [{$(q_0, 11, 11Z_0)$}
                    [{$(q_0, 1, 111Z_0)$}
                    [{$(q_0, \epsilon, 1111Z_0)$}[{$(q_1, \epsilon, 1111Z_0)$}]]
                    [{$(q_1, 1, 111Z_0)$}[{$(q_1, \epsilon, 11Z_0)$}]]]
                    [{$(q_1, 11, 11Z_0)$}[{$(q_1, 1, 1Z_0)$}[{$(q_1, \epsilon, Z_0)$}[{$(q_2, \epsilon, Z_0)$},tikz={\node [draw,red,fit=()] {};}]]]]
                    ]
                [{$(q_1, 111, 1Z_0)$}[{$(q_1, 11, Z_0)$}[{$(q_2, 11, Z_0)$}]]]
                ]
                [{$(q_1, 1111, Z_0)$}[{$(q_2, 1111, Z_0)$}]]
                ]
            \end{forest}
        }
    \end{center}

\end{frame}


\begin{frame}{Our example}

    \begin{center}
        \scalebox{0.85}{
        \begin{tikzpicture}[]
            \node[initial,state] (q0)      {$q_0$};
            \node[state] (q1)  [right=2cm of q0]     {$q_1$};
            \node[state, accepting] (q2)  [right=2cm of q1]    {$q_2$};
            \path[->]
                (q0)  edge[loop above]  node[align=center] {
                                        $0,Z_0 \rightarrow 0Z_0$	\\
                                        $1,Z_0 \rightarrow 1Z_0$	\\			
                                        $0,0 \rightarrow 00$	\\			
                                        $0,1 \rightarrow 01$	\\			
                                        $1,0 \rightarrow 10$	\\			
                                        $1,1 \rightarrow 11$			
                                        } (q0)
                (q0)  edge[swap]  node[align=center] {
                                        $\epsilon,Z_0 \rightarrow Z_0$	\\			
                                        $\epsilon,0 \rightarrow 0$	\\			
                                        $\epsilon,1 \rightarrow 1$			
                                        }  (q1)
                (q1)  edge[loop above]  node[align=center] {
                                        $0,0 \rightarrow \epsilon$	\\			
                                        $1,1 \rightarrow \epsilon$			
                                        } (q1)
                (q1)  edge[swap]  node[align=center] {
                                        $\epsilon,Z_0 \rightarrow \alert{Z_0}$	
                                        } (q2)
                ;
        \end{tikzpicture}
        }
    \end{center}

    \begin{itemize}
        \item acceptance by final state: $L(P)=L_{wwr}$
        \item to accept by empty stack: modify $\delta(q_1,\epsilon,Z_0)=\{(q_2,Z_0)\}$ to $\delta(q_1,\epsilon,Z_0)=\{(q_2,\epsilon)\}$ (erase bottom of the stack symbol), then also $N(P')=L_{wwr}$
    \end{itemize}

\end{frame}


\begin{frame}{Another example: if-else}

    Stop (accept) at first error, e.g. more $\mathtt{else}$'s than $\mathtt{if}$'s

    \textbf{By empty stack:} {\small $P_N=(\{q\},\{\mathtt{if},\mathtt{else}\},\{Z\},\delta_N,q,Z)$}

    \begin{columns}

        \small

        \column{0.48\textwidth}

        \begin{center}
            \scalebox{0.87}{
                \begin{tikzpicture}
                    \node[initial,state] (q) {$q$};
                    \path[->]
                        (q)  edge[loop above] node[align=center] { $\mathtt{if},Z\rightarrow ZZ$\\ $\mathtt{else},Z\rightarrow \epsilon$} (q);
                \end{tikzpicture}
            }
        \end{center} 

        \column{0.52\textwidth}

        \begin{itemize}
            \item[] $\delta_N(q,\mathtt{if},Z)=\{(q,ZZ)\}$ \hfill(push)
            \item[] $\delta_N(q,\mathtt{else},Z)=\{(q,\epsilon)\}$ \hfill(pop)
        \end{itemize}
        
    \end{columns}

    \medskip

    \textbf{By final state:} {\small $P_F=(\{p,q,r\},\{\mathtt{if},\mathtt{else}\},\{Z,X_0\},\delta_F,p,X_0,\{r\})$}

    \begin{columns}

        \small

        \column{0.48\textwidth}

        \begin{center}
            \scalebox{0.87}{
                \begin{tikzpicture}
                    \node[initial,state] (p)      {$p$};
                    \node[state] (q) [right=2cm of p]     {$q$};
                    \node[state,accepting] (r) [right=2cm  of q]     {$r$};
                    \path[->]
                        (q)  edge[loop above] node[align=center] { $\mathtt{if},Z\rightarrow ZZ$\\ $\mathtt{else},Z\rightarrow \epsilon$} (q)
                        (p)  edge node {$\epsilon,X_0\rightarrow ZX_0$} (q)
                        (q)  edge node {$\epsilon,X_0\rightarrow \epsilon$} (r);
                \end{tikzpicture}
            }
        \end{center}          
        
        \column{0.52\textwidth}
        
        \begin{itemize}
            \item[] $\delta_F(p,\epsilon,X_0)=\{(q,ZX_0)\}$ \hfill (start)
            \item[] $\delta_F(q,\mathtt{if},Z)=\{(q,ZZ)\}$ \hfill (push)
            \item[] $\delta_F(q,\mathtt{else},Z)=\{(q,\epsilon)\}$ \hfill (pop)
            \item[] $\delta_F(q,\epsilon,X_0)=\{(r,\epsilon)\}$ \hfill (accept)
        \end{itemize}
        
    \end{columns}

\end{frame}


\begin{frame}{From empty stack to final state}

    \begin{lemma}
        If $L=N(P_N)$ for some PDA $P_N=(Q,\Sigma,\Gamma,\delta_N,q_0,Z_0)$, then there is a PDA $P_F$ such that $L=L(P_F)$.
    \end{lemma}

    \begin{center}
        \scalebox{0.9}{
            \begin{tikzpicture}
                \node[initial,state] (p0)      {$p_0$};
                \node[state] (q0)  [right=2.3cm of p0]    {$q_0$};
                \node[state] (q1a)   [right of=q0]   {};
                \node[state] (q1b)   [below=.6cm of q1a]   {};
                \node[state,draw=none] (pf) [below=.4cm of q0] {$P_N$};
                \node[state,accepting] (q2)   [right=2.3cm of q1a] {$p_f$};
                \node[state] (X)[rectangle,  fit= (q0) (q1a) (q1b), inner sep=0.3cm,rounded corners] {};
                \path[->]
                    (p0)  edge node {$\epsilon,X_0 \rightarrow Z_0X_0$} (q0)
                    (q0)  edge[bend left] node {$\epsilon, X_0\rightarrow \epsilon$} (q2)
                    (q1a)  edge node {$\epsilon, X_0\rightarrow \epsilon$} (q2)
                    (q1b)  edge[bend right] node[swap] {$\epsilon,X_0\rightarrow \epsilon$} (q2);        
            \end{tikzpicture}
        }
    \end{center}

    \textbf{Idea:} Make $Z_0$ a fake bottom (insert a new bottom $X_0$ below), so that we can tell when $P_N$'s stack was empty. Add $\epsilon$-transitions upon seeing $X_0$ from all states to a new, accepting state.

\end{frame}


\begin{frame}{The proof}

    $P_F=(Q\cup \{p_0,p_f\},\Sigma,\Gamma\cup\{X_0\},\delta_F,p_0,X_0,\{p_F\})$, where $\delta_F$ is
    \begin{itemize}
        \item $\delta_F(p_0,\epsilon,X_0)=\{(q_0,Z_0X_0)\}$ (start).
        \item $\forall (q\in Q, a\in \Sigma\cup\{\epsilon\},Y\in \Gamma)$, $\delta_F(q,a,Y)=\delta_N(q,a,Y)$.
        \item In addition, $\delta_F(q,\epsilon,X_0)\ni (p_f,\epsilon)$ for every $q\in Q$.
    \end{itemize}
    We must show that $w\in L(P_N)$ iff $w\in L(P_F)$.
    \begin{itemize}
        \item (If) $P_F$ accepts as follows: $(p_0,w,X_0)\vdash_{P_F}(q_0,w,Z_0X_0)\vdash^*_{P_F=N_F}(q,\epsilon,X_0)\vdash_{P_F}(p_f,\epsilon,\epsilon) $.
        \item (Only if) No other way to go to $p_F$ than the above. \hfill\qedsymbol
    \end{itemize}
    

\end{frame}


\begin{frame}{From final state to empty stack}

    \begin{lemma}
        If $L=L(P_F)$ for some PDA  
        $P_F=(Q,\Sigma,\Gamma,\delta_F,q_0,Z_0,F)$, then there exists a PDA $P_N$ such that $L=N(P_N)$.
    \end{lemma} 
    
    \begin{center}
        \scalebox{0.95}{
            \begin{tikzpicture}
                \node[initial,state] (p0)      {$p_0$};
                \node[state] (q0)  [right=2.3cm of p0]    {$q_0$};
                \node[state,accepting] (q1a)   [right of=q0]   {};
                \node[state,accepting] (q1b)   [below=.6cm of q1a]  {};
                \node[state,draw=none] (pf) [below=.4cm of q0] {$P_F$};
                \node[state] (q2)   [right=2.3cm of q1b] {$p$};
                \node[state] (X)[rectangle,  fit= (q0) (q1a) (q1b), inner sep=0.3cm,rounded corners] {};
                \path[->]
                    (p0)  edge node {$\epsilon,X_0 \rightarrow Z_0X_0$} (q0)
                    (q1a)  edge node {$\epsilon, \hbox{ any }\rightarrow \epsilon$} (q2)
                    (q1b)  edge node[swap] {$\epsilon,\hbox{ any }\rightarrow \epsilon$} (q2)
                    (q2)  edge[loop below] node {$\epsilon,\hbox{ any }\rightarrow\epsilon$} (q2);
            \end{tikzpicture}            
        }
    \end{center}
    \vspace{-12pt}

    \textbf{Idea:} Make $Z_0$ a fake bottom (insert a new bottom below), because $P_F$ could accidentally empty stack in a nonfinal state. Add $\epsilon$-transitions (upon any stack symbol) from final states to a new state, there empty the stack without reading any input symbols.

\end{frame}


\begin{frame}{The proof}

    Let $P_N=(Q\cup \{p_0,p\},\Sigma,\Gamma\cup\{X_0\},\delta_N,p_0,X_0)$, where
    \begin{itemize}
        \item $\delta_N(p_0,\epsilon,X_0)=\{(q,Z_0X_0)\}$ (start)
        \item $\forall (q\in Q, a \in \Sigma\cup\{\epsilon\},Y\in \Gamma)$ $\delta_N(q,a,Y)=\delta_F(q,a,Y)$ (simulate)
        \item $\forall (q \in F,Y\in \Gamma\cup\{X_0\})$, $\delta_N(q,\epsilon,Y)\ni (p,\epsilon)$ (i.e. accept if $P_F$ accepts)
        \item $\forall (Y\in \Gamma\cup\{X_0\}), \delta_N(p,\epsilon,Y)=\{ (p,\epsilon)\}$ clean the stack.
    \end{itemize}
    The proof $w\in N(P_N)$ iff $w\in L(P_F)$ is similar as before.\hfill\qedsymbol

\end{frame}


\begin{frame}{Unseen data cannot affect computation}

    \begin{lemma}
        If $(q,x,\alpha)\vdash_P (p,y,\beta) $, then for any $w\in \Sigma^*$ and $\gamma\in\Gamma^*$ we also have 
        $(q,xw,\alpha\gamma)\vdash^*_P(p,yw,\beta\gamma)$. (In particular, $\gamma=\epsilon$ or $w=\epsilon$.)
    \end{lemma}
    \textbf{Proof:} Induction on the number length of the sequence of configurations that take $(q,xw,\alpha\gamma)$ to $(p,yw,\beta\gamma)$. Each of the moves $(q,x,\alpha)\vdash^*_P(p,y,\beta)$ is justified without using $w$ and/or $\gamma$ in any way. The moves are still valid with $w,\gamma$ on the input/stack.\hfill\qedsymbol

    \medskip

    \begin{lemma}
        If $(q,xw,\alpha)\vdash^*_P (p,yw,\beta) $, then also $(q,x,\alpha)\vdash^*_P(p,y,\beta)$.
    \end{lemma}
    \textbf{NB:} Not true for stack, the computation may require $\gamma$ on the stack and then push it back. (E.g. $L=\{0^i1^i0^j1^j\}$, configuration $(p,0^{i-j}1^i0^j1^j,0^jZ_0)\vdash^* (q,1^j,0^jZ_0)$, inbetween clear the stack.)

\end{frame}


\section*{2.10 Equivalence of PDA and context-free grammars}


\begin{frame}{Equivalence of PDA and CFG}

    \begin{theorem}
        The following statements about $L\subset\Sigma^*$ are equivalent:
        \begin{enumerate}[(i)]
            \item There exists a context-free grammar such that $L(G)=L$.
            \item There exists a PDA such that $L(P)=L$.
            \item There exists a PDA such that $N(P)=L$.
        \end{enumerate}
    \end{theorem}
        
    \begin{center}
        \begin{tikzpicture}
            \node[elliptic state][align=center] (p)      {Context-free\\ grammar};
            \node[elliptic state][align=center] (q) [right=1cm of p]     {PDA by\\empty stack};
            \node[elliptic state][align=center] (r) [right=1cm  of q]     {PDA by\\final state};
            \path[->]
                (p)  edge[bend left] node {} (q)
                (q)  edge[bend left] node {} (p)
                (q)  edge[bend left] node {} (r)
                (r)  edge[bend left] node {} (q)
            ;
        \end{tikzpicture}    
    \end{center}

    We have already shown $(ii)\Leftrightarrow(iii)$. To prove equivalence with a context-free grammar, we use acceptance by empty stack.

\end{frame}


\section*{Context-free grammar to pushdown automaton}


\begin{frame}{CFG to PDA}

    \begin{block}{The construction}
        Given $G=(V,T,\mathcal P,S)$, construct $P=(\{q\},T,V\cup T,\delta,q,S)$:
        \begin{enumerate}[(1)]
            \item for each $ A\in V$, \alert{$\delta(q,\epsilon, A)=\{(q,\beta)\mid A\rightarrow \beta \in\mathcal P\}$} \\ \hfill [apply rule]
            \item for each $a\in T$, \alert{$\delta(q,a,a)=\{(q,\epsilon)\}$}\\ \hfill [match terminal]
        \end{enumerate}   
    \end{block} 

    \textbf{How it works:}
    \begin{itemize}
        \item a \alert{leftmost} derivation is simulated by the PDA
        \item current sentential form = part of input read + stack contents
        \item see a variable: apply rule, a terminal: read \& pop from stack
    \end{itemize}

\end{frame}


\begin{frame}{An example}

    \begin{example}
        $I\rightarrow a\mid b\mid Ia\mid Ib\mid I0\mid I1$,\\
        $E\rightarrow I\mid E*E\mid E+E\mid (E)$
    \end{example}
        
    $\Sigma=\{a,b,0,1,(,),+,*\}$, $\Gamma=\Sigma\cup\{I,E\}$,  $\delta$ is defined as follows:

    \begin{itemize}
        \item $\delta(q,\epsilon,I)=\{(q,a),(q,b),(q,Ia),(q,Ib),(q,I0),(q,I1)\}$
        \item $\delta(q,\epsilon,E)=\{(q,I),(q,E*E),(q,E+E),(q,(E))\}$
        \item $\delta(q,s,s)=\{(q,\epsilon)\}$ for all $s\in \Sigma$ (e.g. $\delta(q,+,+)=\{(q,\epsilon)\}$)
        \item $\delta(q,x)$ is empty otherwise
    \end{itemize}

    \alert{Leftmost derivation:} $E\Rightarrow E*E\Rightarrow I*E\Rightarrow a*E\Rightarrow a*I\Rightarrow a*b$\\       	
    
    \medskip

    The sequence of configurations:

    $(q,a*b,E)$
    $\vdash$ $(q,a*b,E*E)$
    $\vdash$ $(q,a*b,I*E)$
    $\vdash$ $(q,a*b,a*E)$
    $\vdash$ $(q,*b,*E)$
    $\vdash$ $(q,b,E)$
    $\vdash$ $(q,b,I)$
    $\vdash$ $(q,b,b)$
    $\vdash$ $(q,\epsilon,\epsilon)$

\end{frame}


\begin{frame}{Proof that $N(P)=L(G)$\hfill \alert{(i) $w\in L(G)\Rightarrow w\in N(P)$}}

    Start with a leftmost derivation $S=\gamma_1\Rightarrow_{lm}\ldots\Rightarrow_{lm}\gamma_n=w$.

    Prove by induction on $i$ that $(q,w,S)\vdash_P^* (q, v_i,\alpha_i)$, where $\gamma_i=u_i\alpha_i$ is the $i$-th sentential form and $u_iv_i=w$.

    If $\gamma_i$ contains only terminals, set $\gamma_i=w=u_i, v_i=\epsilon=\alpha_i$. Otherwise, write $\gamma_i=u_iA\alpha_i$, where $u_i\in T^*$ and $A\in V$ is the leftmost variable.

    By induction we have $(q,w,S)\vdash_P^* (q, v_i,A\alpha_i)$, $w=u_iv_i$.

    For the step $\gamma_i\Rightarrow_{lm}\gamma_{i+1}$ we used some rule $A\rightarrow\beta\in P$. The PDA replaces $A$ on the stack with $\beta$, moves to configuration $(q,v_i,\beta\alpha_i)$.

    We pop all terminals $v\in \Sigma^*$ from the beginning of $\beta\alpha$ (matching them with the input): $v_i=vv_{i+1}$ and $\beta\alpha=v\alpha_{i+1}$

    We got to $(q,v_{i+1},\alpha_{i+1})$, corresponds to the sentential form $\gamma_{i+1}$.
    
\end{frame}


\begin{frame}{Proof that $N(P)=L(G)$\hfill \alert{(ii) $w\in N(P)\Rightarrow w\in L(G)$}}

    \vspace{-3pt}
    Prove that if $(q,u,X)\vdash_P^*(q,\epsilon,\epsilon)$, then $X\Rightarrow_G^* u$. By induction on the number of moves. \textbf{Basis} \alert{$n=1$} move:
    \begin{itemize}
        \item $X=a\in\Sigma$: $\delta(q, a, a)\ni (q,\epsilon)$, $u=a$, 0-step derivation
        \item $X=A\in \Gamma$: $\delta(q,\epsilon,A)\ni (q,\epsilon)$ coming from $A\rightarrow\epsilon\in\mathcal P$, $u=\epsilon$
    \end{itemize} 

    \vspace{-3pt}
    \textbf{Induction step} \alert{$n>1$} moves: if the first move is \alert{[match terminal]}, don't extend the derivation, if it is \alert{[apply rule]}: $A$ on top of stack was replaced by $\beta=Y_1Y_2\ldots Y_k$, for a rule $A\to\beta\in\mathcal P$.

    \begin{columns}

        \column{0.78\textwidth}
    
        Split $u=u_1\ldots u_k$ s.t. while popping $Y_i$ we read~$u_i$, i.e. $(q,u_iu_{i+1}\ldots u_k,Y_i)\vdash^*(q,u_{i+1}\ldots u_k,\epsilon)$

        \medskip
        
        Thus also $(q,u_i,Y_i)\vdash^*(q,\epsilon,\epsilon)$, by induction assumption we get $Y_i\Rightarrow^*u_i$. Together:
        {\small
        $$
        A\Rightarrow Y_1Y_2\ldots Y_k\Rightarrow^* u_1Y_2\ldots Y_k\Rightarrow^* \ldots \Rightarrow^* u_1u_2\ldots u_k
        $$
        } 
        
        \vspace{-6pt}\hfill\qedsymbol
    
        \column{0.22\textwidth}

        \scalebox{0.85}{
            \input{files/PDACFG.pdf_t}
        }
        
    \end{columns}    
       
\end{frame}


\section*{Pushdown automaton to context-free grammar}


\begin{frame}{PDA to CFG}

    \begin{block}{The construction}
        Given $P=(Q,\Sigma,\Gamma,\delta,q_0,Z_0)$, construct $G=(V,T,\mathcal P,S)$ where $V=\{S\}\cup\{[pXq]\mid p,q\in Q,X\in\Gamma\}$ and the productions are:   
        \begin{enumerate}[(i)]
            \item for every state $p\in Q$ add $S\to [q_0Xp]$ 
            \item for every transition $({\color{red}p},Y_1Y_2\ldots Y_k)\in\delta({\color{red}q,a,X})$ (incl. $a=\epsilon$) and \alert{all $k$-tuples of states} $p_1,\dots,p_{k-1},{\color{blue}p_k}\in Q$ add
            
            \vspace{-6pt}
            $$
            [{\color{red}qX}{\color{blue}p_k}]\rightarrow {\color{red}a}[{\color{red}p}Y_1p_1][p_1Y_2p_2]\ldots [p_{k-1}Y_k{\color{blue}p_k}]
            $$                  
        \end{enumerate}        
        %\vspace{-3pt}      
        In particular, for $(p,\epsilon)\in\delta(q,a,X)$ (i.e., $k=0$) add $[qXp]\rightarrow a$.
    \end{block}

    \vspace{-6pt}
    \begin{itemize}
        \item key event: pop a symbol $X$, while changing from state $q$ to $r$
        \item variables: $[qXr]$ for $q,r\in Q$ and $X\in \Gamma$, plus a new variable~$S$
        $$
        L([qXr])=\{w\in\Sigma^*\mid (q,w,X)\vdash_P^*(r,\lambda,\lambda)\}
        $$
        \item $S$ to choose (guess) in which state the stack is emptied
    \end{itemize}

\end{frame}


\begin{frame}{An example}

    \begin{columns}

        \column{0.7\textwidth}\centering
        
        Given $P=(\{q\},\{\mathtt{if},\mathtt{else}\},\{Z\},\delta,q,Z)$
        
        \smallskip

        $\delta(q,\mathtt{if},Z)=\{(q,ZZ)\}$\\        
        $\delta(q,\mathtt{else},Z)=\{(q,\epsilon)\}$
        
        \column{0.3\textwidth}

        \begin{center}
            \scalebox{0.9}{
                \begin{tikzpicture}
                    \node[initial,state] (q) {$q$};
                    \path[->]
                        (q)  edge[loop above] node[align=center] { $\mathtt{if},Z\rightarrow ZZ$\\ $\mathtt{else},Z\rightarrow \epsilon$} (q);
                \end{tikzpicture}
            }
        \end{center} 

    \end{columns}

    Construct $G=(V,\{\mathtt{if},\mathtt{else}\},\mathcal P,S)$

    \begin{itemize}
        \item variables: $V=\{S,[qZq]\}$ 
        \item production rules:
        \begin{itemize}
            \item $S\rightarrow [qZq]$            
            \item $[qZq]\rightarrow \mathtt{else}$
            \item $[qZq]\rightarrow \mathtt{if}[qZq][qZq]$
            
        \end{itemize}        
    \end{itemize}    
    
    In this example, $S$ and $[qZq]$ generate the same words, so we can simplify:
         $G=(\{S\},\{\mathtt{if},\mathtt{else}\},\{S\rightarrow \mathtt{if}SS\mid\mathtt{else}\},S)$
    
\end{frame}


\begin{frame}{Another example: $\{0^n1^n\mid n>0\}$}

    \vspace{-6pt}
    {\small    
        \begin{center}
            \begin{tabular}{l l c}
                $\delta$ & Productions & \\\hline
                & $S\rightarrow [pZp]\mid [pZq]$ & (1)\\
                $\delta(p,0,Z)\ni (p,A)$	& $[pZp]\rightarrow 0[pAp] $ & (2)\\
                & $[pZq]\rightarrow 0[pAq] $& (3)\\
                $\delta(p,0,A)\ni (p,AA)$ & $[pAp]\rightarrow 0[pAp][pAp]$ & (4)\\
                & $[pAp]\rightarrow 0[pAq][qAp] $ & (5)\\
                & $[pAq]\rightarrow 0[pAp][pAq] $ & (6)\\
                & $[pAq]\rightarrow 0[pAq][qAq] $ & (7)\\
                $\delta(p,1,A)\ni (q,\epsilon)$ & $[pAq]\rightarrow 1$ & (8)\\			
                $\delta(q,1,A)\ni (q, \epsilon)$ & $[qAq]\rightarrow 1$ & (9)			
            \end{tabular}
        \end{center}
    }

    \bigskip

    \begin{columns}

        \column{0.5\textwidth}

        Derivation of $0011$:\vspace{-12pt}
        \begin{align*}
            S &\Rightarrow^{(1)} [pZq] \Rightarrow^{(3)} 0[pAq]\\
              &\Rightarrow^{(7)} 00[pAq][qAq]\\
              &\Rightarrow^{(8)} 001[qAq]\Rightarrow^{(9)} 0011   
        \end{align*}

        \column{0.5\textwidth}

        \begin{center}
            \scalebox{0.9}{
                \begin{tikzpicture}
                    \node[initial,state] (p)      {$p$};
                    \node[state] (q)  [right=2cm of p]     {$q$};
                    \path[->]
                        (p)  edge[loop above]  node[align=center] {
                            $0,Z \rightarrow A$	\\
                            $0,A \rightarrow AA$	
                        } (p)
                        (p)  edge[swap]  node[align=center] {
                            $1,A \rightarrow \epsilon$			
                        }  (q)
                        (q)  edge[loop above]  node[align=center] {
                            $1,A \rightarrow \epsilon$			
                        } (q);           
                \end{tikzpicture}                
            }
        \end{center}

    \end{columns}

\end{frame}


\begin{frame}{Sketch of proof that $L(G)=N(P)$}

    \begin{columns}

        \column{0.7\textwidth}

        It suffices to show that:
        $$
        [qXp]\Rightarrow^*w\ \text{ iff }\ (q,w,X)\vdash^*(p,\epsilon,\epsilon)
        $$

        In both directions, the proof is done by induction (number of moves/steps).
        
        \column{0.3\textwidth}

        \begin{center}
            \input{files/PDACFG2.pdf_t}    
        \end{center}

        \hfill\qedsymbol
                
    \end{columns}

\end{frame}


\begin{frame}{Summary of Lecture 7}
	
	\begin{itemize}        
		\item Pushdown automaton: extend an $\epsilon$-NFA with a stack memory (potentially infinite), pop the top symbol, decide based on $(q,a,X)$, can push a finite string of stack symbols
        \item Acceptance by final state $L(P)$ and by empty stack $N(P)$, conversion between the two options
        \item Pushdown automata accept exactly context-free languages (constructions: CFG to PDA and PDA to CFG)		
	\end{itemize}

\end{frame}


\end{document}

    
    \begin{frame}{Shrnutí}
    \begin{itemize}
        \item Zásobníkový automat PDA je $\epsilon$--NFA automat rozšířený o zásobník, potenciálně nekonečnou paměť
        
        \begin{itemize}
            \item a zásobníkovou abecedu, počáteční zásobníkový symbol, přechodová funkce čte a píše na zásobník, píše i řetězec
        \end{itemize}
        \item Přijímání koncovým stavem a prázdným zásobníkem, pro nedeterministiké PDA přijímají stejnou třídu jazyků
        \item a to bezkontextové jazyky, generované bezkontextovými gramatikami.
    \end{itemize}
    \end{frame}
    
    