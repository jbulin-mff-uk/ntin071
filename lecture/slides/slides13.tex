\documentclass[handout]{beamer}

\input{header.tex}




\title{Lecture 13 -- Intro to Complexity theory}


\begin{document}


\frame{\titlepage}


\begin{frame}{Recap of Lecture 12}

    \begin{itemize}
        \item the Diagonal language $L_D$ is not recursively enumerable
        \item the Universal language $L_U$, the Universal TM: simulate any $M$ on any $w$
        \item recursive languages are closed under complement
        \item Post's theorem: $L$ recursive iff both $L,\overline{L}$ are RE
        \item $L_U$, $\overline{L_D}$ are recursively enumerable but not recursive
        \item reductions between decision problems
        \item the Halting problem is undecidable        
        \item (Rice's thm: nontriv. properties of programs are undecidable)
        \item Undecidable problems about context-free grammars
        \item Source of undecidability: Post's correspondence problem
    \end{itemize}

\end{frame}


\begin{frame}{Summary of Lecture 13}

    \begin{itemize}
        \item time complexity
        \item 
    \end{itemize}

\end{frame}


\section{\sc Chapter 5: Intro to Complexity}


\section*{Time complexity}


\begin{frame}{Asymptotic notation}
    
    \textbf{Big-O notation:} Let $f,g: \mathbb{N}\to \mathbb{R}^+$. We say that \alert{$f(n)\in O(g(n))$}, if there exist $C,n_0\in \mathbb{N}^+$ such that
    $$
    (\forall n\geq n_0)\ f(n)\leq C\cdot g(n)
    $$

    e.g. $\limsup_{n\to\infty}\frac{f(n)}{g(n)}<\infty$. In that case we say that $g(n)$ is an [asymptotic] \alert{upper bound} [up to a constant multiple] for $f(n)$. 
    
    \textbf{Note:} Often the imprecise term `upper bound' is used; sometimes you will encounter $f(n)=O(g(n))$.

    For example, $f(5n^3+2n^2+22n+6)\in O(n^3)$ with $n_0=10$, $C=6$.

    \medskip

    \textbf{Little-o notation:} \alert{$f(n)\in o(g(n))$}, if for all $c>0$ there exists $n_0\in \mathbb{N}^+$ so that
    $(\forall n\geq n_0)\ f(n)<c\cdot g(n)$, i.e. $\lim_{n\to\infty}\frac{f(n)}{g(n)}=0$. Then we say $f(n)$ is [asymptotically] \alert{dominated} by $g(n)$.
    
    Analogously for $\geq$ instead of $\leq$:  $\Omega,\omega$.

\end{frame}


\begin{frame}{Classes of time complexity}

    \begin{definition}
        Let $M$ be a Turing machine that halts on every input. The \alert{time complexity} of $M$ is the function $f:\mathbb{N}\to \mathbb{N}$, where $f(n)$ is the maximum number of computation steps for inputs of length $n$.
    \end{definition}
    
    \begin{definition}
        For $t:\mathbb{N}\to \mathbb{R}^+$, \alert{$\mathrm{TIME}(t(n))$} is the class of all languages decidable by a TM of time complexity in $O(t(n))$ (i.e., always halts and for $|w|=n$ correctly answers in at most $O(t(n))$ steps).
    \end{definition}

    \textbf{NB:} Here we mean the standard, single-tape, deterministic TM.
    
\end{frame}


\begin{frame}{Example}

    \begin{example}[$L=\{0^i1^i \mid i\geq 0\}$ is in $\mathrm{TIME}(n^2)$]
        \begin{enumerate}
            \item check if the input is $0^i1^j$, if a $0$ follows a $1$, reject (time $O(n)$)
            \item return to the beginning: hidden in the constant $O(2n)=O(n)$
            \item go through the $0$s, in time $O(n^2)$
            \begin{enumerate}
                \item rewrite the next $0$ to $X$
                \item find the first $1$, rewrite to $X$
                \item return to the beginning
            \end{enumerate}
            \item if no more $0$s, check that no more $1$s remain and accept (if $1$ found, reject)  (time $O(n)$)\vspace{-6pt}
        \end{enumerate}
    \end{example}
    
    \vdots
    Can we do it faster?

\end{frame}


\begin{frame}{Can we do it faster?}

    \textbf{Idea:} ``compare the binary representations of $i$ and $j$'', $\log n$ bits, for each bit need to traverse through the word


    \begin{example}[$L=\{0^i1^i \mid  i\geq 0\}$ is also in $\mathrm{TIME}(n\log n)$]
        \begin{enumerate}
            \item check if the input is $0^i1^j$ \alert{and even length} (time $O(n)$)          
            \item iterate while there are $0$s, in time $O(n\log n)$
            \begin{enumerate}
                \item rewrite every other $0$ to $X$, then every other $1$ to $X$
                \item check if the number of remaining $0$s+$1$s is even, if not, reject                
            \end{enumerate}
            \item if no more $0$s, check that no more $1$s and accept (time $O(n)$)
            \end{enumerate}    
    \end{example}

    \vdots
    Can we do it even faster?

\end{frame}


\begin{frame}{Time complexity and regular languages}
    
    Can we do it even faster? Not really.

    \begin{theorem}
        Every language decidable in time $o(n \log n)$ [on a single-tape, deterministic TM] is regular. %problem 7.49
    \end{theorem}

    [We omit the proof.]

\end{frame}

    
\begin{frame}{Multi-tape TM}
    
    \begin{example}[Multi-tape TM for $L=\{0^i1^i \mid  i\geq 0\}$]
        \begin{itemize}
            \item copy 0s to Tape 2
            \item at first 1, switch state; erase 1 from Tape 1 \& 0 from Tape 2
            \item accept if both tapes are erased
        \end{itemize}

    \end{example}
    
    \begin{lemma}
        Every multi-tape Turing Machine with time complexity $t(n)$ is equivalent to a [single-tape] Turing Machine with time complexity $O(t^2(n))$.
    \end{lemma}
    \textbf{Proof:} Simulation of $n$ steps of a $k$-tape TM can be done in $O(n^2)$ moves since one step takes $4n+2k$ moves (heads at most $2n$ fields apart, read, write, move head marks).\hfill\qedsymbol

\end{frame}


\begin{frame}{Nondeterministic time complexity}
    
    The \alert{time complexity} of a \textbf{nondeterministic} Turing machine that always halts is defined analogously: $f(n)$ is the maximum number of steps in \textbf{any branch} of the computation tree.
    
    \begin{definition}
        For $t:\mathbb{N}\to \mathbb{R}^+$, \alert{$\mathrm{NTIME}(t(n))$} is the class of all languages decidable by a nondeterm. TM of time complexity in $O(t(n))$.
    \end{definition}
    \vspace{-6pt}
    (An NTM \alert{decides} $L$ if halts on all inputs and recognizes $L$.)

    \smallskip

    \begin{theorem}        
    Any nondeterministic TM of time complexity $t(n)\geq n$, has a deterministic equivalent of time complexity in $2^{O(t(n))}$.
    \end{theorem}

    \begin{corollary}
        If $t(n)\geq n$, then $\mathrm{NTIME}(t(n))\subseteq \mathrm{TIME}(2^{O(t(n))})$.
    \end{corollary}
    
\end{frame}


\begin{frame}{Proof}

    Recall the construction: BFS of the computation graph, keep a queue of configurations to process.
    \begin{itemize}
        \item At most $d$ possible transitions for any $(q,X)\in (Q\setminus F)\times \Gamma$. 
        \item So after $k$ steps at most $d^k$ configurations.
        \item Processing one configuration can be `hidden' in the constant.
        \item Therefore the simulation is in time:
        $$
        O(t(n)d^{t(n)})=2^{O(t(n))}
        $$
        \item We need to simulate multiple tapes, but: 
        $$
        (2^{O(t(n))})^2=2^{O(2t(n))}=2^{O(t(n))}
        $$

        \vspace{-12pt}
        \hfill\qedsymbol
    \end{itemize}

\end{frame}


\section*{P vs. NP}


\begin{frame}{The class P}

    \begin{definition}
        Let \alert{$\mathrm{P}$} (also \alert{$\mathrm{PTIME}$}) be the class of all languages decidable in \alert{polynomial time} by a [single-tape, deterministic] Turing machine:

        \vspace{-18pt}
        $$
        \mathrm{P}=\bigcup_k \mathrm{TIME}(n^k)
        $$
        \vspace{-9pt}
    \end{definition}
    \vspace{-9pt}
    \begin{itemize}
        \item Path in a graph
        \item Primality of an integer (Agrawal, Kayal, Saxena 2002)
        \item Linear programming
        \item Horn-SAT
    \end{itemize}
    \vspace{-3pt}
    (The last two are $\mathrm{P}$-complete under $\mathrm{LOGSPACE}$ reductions.)

    \medskip

    \begin{theorem}[$CFL\subseteq P$]
        Every context free language belongs to $\mathrm{P}$.
    \end{theorem}  
    
    \vspace{-10pt}
    \textbf{Proof:}
        Take a ChNF grammar for $L$. Given input $\omega$, run the CYK algorithm (polynomial, in $O(n^3)$).\hfill\qedsymbol

\end{frame}


    
\begin{frame}{The class NP: verifier-based definition}
    
    \begin{definition}
        A \alert{verifier} for a language $L$ is an algorithm $V$ such that:
        
        \vspace{-24pt}
        $$
        L=\{w\mid \text{there exists a finite string $c$ such that $V$ accepts }\langle w,c\rangle\}
        $$
        \vspace{-24pt}
    \end{definition}
    \vspace{-9pt}
    Such a $c$ is called a \alert{certificate}. It can be over any alphabet!

    Complexity of verifiers is only considered wrt. the length of $w$: a \alert{polynomial verifier} must halt in time $O(|w|^k)$ for some $k>0$. Then we can assume the cerfificate has polynomial length (otherwise the verifier cannot even read it).
    
    \begin{definition}
        \alert{$\mathrm{NP}$} is the class of all languages that have a polynomial verifier.
    \end{definition}
    \vspace{-9pt}
    That is, there is an algorithm that works in time polynomial in $|w|$ and when given $w\in L$ and a cerfificate $c$ validates that $c$ is a valid certificate for $w\in L$.

\end{frame}


\begin{frame}{Hamiltonian path}
    
    A \alert{Hamiltonian path} in a directed graph $G$ is a directed path $P$ that visits each vertex of $G$ exactly once.
    
    $$
    \mathrm{HAMPATH}=\{\langle G\rangle\mid G\text{ contains a Hamiltonian path}\}
    $$

    \begin{itemize}  
        \item complexity for graphs can be measured just wrt. $|V|$ ($|E|$ is at most quadratic, thus polynomial)    
        \item the \alert{certificate} is the path (sequence of vertices)
        \item the algorithm verifies that the sequence is indeed a path containing each vertex exactly once; this can be easily done in polynomial time wrt. $|V|$
        \item for $\overline{\mathrm{HAMPATH}}$ we do not know whether a polynomial verifier exists (we only know the problem is in $\mathrm{EXPTIME}$)
    \end{itemize}

\end{frame}


\begin{frame}{The class $NP$: nondeterminism-based definition}
    
    \begin{definition}
        $\mathrm{NP}$ is the class of all languages that have a polynomial verifier.
    \end{definition}
    \begin{theorem}
    $\mathrm{NP}=\bigcup_k NTIME(n^k)$.
    \end{theorem}

    \textbf{Idea:} convert a verifier to a nondeterministic TM, and vice versa
    \begin{itemize}
        \item[$\Rightarrow$] the NTM guesses the certificate, then simulates the verifier
        \item[$\Leftarrow$] the verifier takes as a certificate the accepting path of the NTM (more precisely, the sequence of nondeterministic choices that leads to acceptance), then simulates the NTM
    \end{itemize}

\end{frame}
    
\begin{frame}{Proof}
    
    \alert{$\mathrm{NP}\subseteq\bigcup_k NTIME(n^k)$:} Let $L\in\mathrm{NP}$ and take a polynomial verifier $V$ for $L$, say it works in time $C\cdot |\omega|^k$. Construct an NTM $M$:

    Given input $\omega$:
    
    \vspace{-3pt}
    \begin{itemize}
        \item nondeterministically guess a certificate $c$ (of $|c|\leq C\cdot |\omega|^k$)
        \item simulate $V$ on input $\langle \omega, c\rangle$
        \item if $V$ accepted, $M$ accepts
    \end{itemize}
        
    \alert{$\bigcup_k NTIME(n^k)\subseteq\mathrm{NP}$:} Let $L\in NTIME(n^k)$, i.e., $L=L(M)$ for an NTM $M$ working in time $O(n^k)$. Construct a polynomial verifier $V$:

    Given input $\langle w, c\rangle$, interpret $c$ as sequence of choices: $c_i=j$ means ``at step $i$ use $j$th possible transition'' (order as in $\mathrm{code}(M)$)
 
    \vspace{-3pt}
    \begin{itemize}        
        \item simulate $M$ on input $w$
        \item at each step $i$ choose the $c_i$th possible transition
        \item accept if this computation path leads to acceptance\hfill\qedsymbol     
    \end{itemize}    

\end{frame}


\begin{frame}{Example: CLIQUE is in NP}

    $$
    \mathrm{CLIQUE}=\{\langle G,k\rangle\mid G \text{ is a graph which contains }K_k\text{ as a subgraph}\}
    $$

    \textbf{Polynomial verifier for $\mathrm{CLIQUE}$}: input $\langle \langle G,k\rangle,c\rangle$
    \begin{itemize}
        \item interpret the certificate $c$ as a list of vertices
        \item check that $c$ contains $k$ vertices
        \item check that $c$ induces a complete subgraph of $G$
    \end{itemize}

    \textbf{Nondeterministic TM deciding $\mathrm{CLIQUE}$}: input $\langle G,k\rangle$
    \begin{itemize}
        \item nondeterministically choose a $k$-element subset $c\subseteq V$
        \item check that $c$ induces a complete subgraph of $G$
    \end{itemize}

\end{frame}


\section*{Polynomial-time reductions and NP-completeness}


\begin{frame}{Polynomial-time reducibility}
    
    Recall the notion of \alert{reduction} between decision problems. Now we additionally require that the algorithm is polynomial-time:

    \medskip
    
    A [total] function $f: \Sigma^*\to \Delta^*$ is \alert{polynomial-time computable}, if there exists a [deterministic] Turing Machine $M$ and $C,k>0$ such that for each $\omega\in\Sigma^*$, $M$ halts in at most $C\cdot |\omega|^k$ steps with $f(\omega)\in\Delta^*$ being the non-blank contents of its tape.

    \medskip

    \begin{definition}
        A language $A\subseteq\Sigma^*$ is \alert{polynomial-time reducible} to a language $B\subseteq\Delta^*$, \alert{$A\leq_P B$}, if there exists a polynomial-time computable function $f: \Sigma^*\to \Delta^*$ such that for all $\omega\in \Sigma^*$:

        \vspace{-12pt}
        $$
        \omega\in A \ \Leftrightarrow\ f(\omega)\in B
        $$
        \vspace{-20pt}

        Then we call $f$ a \alert{polynomial-time reduction} from $A$ to $B$.
    \end{definition}
    
\end{frame}


\begin{frame}{Example: Hamiltonian path from source to target}
   
    \begin{itemize}
        \item $\mathrm{HAMPATH}=\{\langle G\rangle\mid G\text{ contains a Hamiltonian path}\}$
        \item $st$-$\mathrm{HAMPATH}=\{\langle G,s,t\rangle\mid G\text{ has a H. path from $s$ to $t$}\}$
    \end{itemize}
    
    \begin{example}
        $\mathrm{HAMPATH}$ and $st$-$\mathrm{HAMPATH}$ are \alert{polynomial-time interreducible}, i.e. each polynomial-time reduces to the other.
    \end{example}

    \textbf{The reduction $\mathrm{HAMPATH}\leq_P st\text{-}\mathrm{HAMPATH}$}:
    
    Given $G$ create $G'$ by adding new vertices $s,t$ and all edges from $s$ to $V_G$ and from $V_G$ to $t$; define $f(\langle G\rangle)=\langle G',s,t\rangle$    
    $$
    \langle G\rangle\in\mathrm{HAMPATH}\ \Leftrightarrow\ \langle G',s,t\rangle\in st\text{-}\mathrm{HAMPATH}
    $$

    \textbf{The reduction $st\text{-}\mathrm{HAMPATH}\leq_P \mathrm{HAMPATH}$}:
    construct $G'$ by adding new vertices $s',t'$, edges $s'\to s,t\to t'$; $f(\langle G,s,t\rangle)=\langle G'\rangle$   

\end{frame}


\begin{frame}{Example: 3SAT is polynomial-time reducible to CLIQUE}
    
    A propositional formula is in \alert{CNF} if it is a conjunction of clauses, and \alert{3-CNF} if each clause contains exactly 3 literals.

    \begin{itemize}
        \item $\alert{\mathrm{SAT}}=\{\langle\phi\rangle\mid \varphi\text{ is a satisfiable CNF formula}\}$
        \item $\alert{\mathrm{3SAT}}=\{\langle\phi\rangle\mid \varphi\text{ is a satisfiable 3-CNF formula}\}$
    \end{itemize}
    
    \begin{theorem}
        $\mathrm{3SAT}$ is polynomial-time reducible to $\mathrm{CLIQUE}$.
    \end{theorem}
    \textbf{Proof:} Vertices are occurrences of literals (three vertices per clause). Include all edges except for:
    \begin{itemize}
        \item between vertices from the same clause
        \item between a variable and its negation ($x$ and $\neg x$)
    \end{itemize}
    Set $k=\#\text{clauses}$. Note: Exactly one literal per clause selected.\hfill\qedsymbol

    \textbf{Exercise:} 3SAT is polynomial-time interreducible with SAT.

\end{frame}


\end{document}
